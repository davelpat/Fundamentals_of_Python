10-4c
Projects
Redo the producer/consumer program so that it allows multiple consumers. Each consumer must be able to consume the same data before the producer produces more data.

Sometimes servers are down, so clients cannot connect to them. Python raises an exception of type ConnectionRefusedError in a client program when a network connection is refused. Add code to the day/time client program to catch and recover from this kind of exception.

Modify the code in the day/time server application so that the user on the server side can shut the server down. That user should be able to press the return or enter key at the terminal to do this.

Modify the doctor application discussed in this chapter so that it tracks clients by name and history. A Doctor object has its own history list of a patient’s inputs for generating replies that refer to earlier conversations, as discussed in Chapter 5. A Doctor object is now associated with a patient’s name. The client application takes this name as input and sends it to the client handler when the patient connects. The client handler checks for a pickled file with the patient’s name as its filename (“<patient name>.dat”). If that file exists, it will contain the patient’s history, and the client handler loads the file to create the Doctor object. Otherwise, the patient is visiting the doctor for the first time, so the client handler creates a brand-new Doctor object. When the client disconnects, the client handler pickles the Doctor object in a file with the patient’s name.

Design, implement, and test a network application that maintains an online phone book. The data model for the phone book is saved in a file on the server’s computer. Clients should be able to look up a person’s phone number or add a name and number to the phone book. The server should handle multiple clients without delays. Unlike the doctor program, there should be just one phone book that all clients share. The server creates this object at start-up and passes it to the client handlers.

Convert the ATM application presented in Chapter 9 to a networked application. The client manages the user interface, whereas the server and client handler manage connecting to and the transactions with the bank. Do not be concerned about synchronization problems in this project.

Write the tester program for readers and writers of a shared Counter object. A sample run is shown in Figure 10-4.

Add synchronization to the ATM program of Project 6. You will need to give concurrent readers access to a single account, as long as a writer is not writing to it, and give a single writer access, as long as other writers and readers are not accessing the account. Hint: just complete the ThreadSafeSavingsAccount class discussed in this chapter, and use it to create account objects in the Bank class.

Jack has been working on the shared cell classes for the producer-consumer problem and the readers and writers problem, and he notices some serious redundancy in the code. The read and write methods are the same in both classes, and both classes include an instance variable for the data. Jill, his team manager, advises him to place this redundant code in a parent class named SharedCell. Then two subclasses, named PCSharedCell and RWSharedCell, can inherit this code and define the methods beginRead, endRead, beginWrite, and endWrite, to enforce their specific synchronization protocols. Also, the __init__ method in each subclass first calls the __init__ method in the SharedCell class to set up the data, and then adds the condition(s) and other instance variables for its specific situation. Jack has called in sick, so you must complete this hierarchy of classes and redo the demo programs so that they use them.

A crude multi-client chat room allows two or more users to converse by sending and receiving messages. On the client side, a user connects to the chat room as in the ATM application, by clicking a Connect button. At that point, a transcript of the conversation thus far appears in a text area. At any time, the user can send a message to the chat room by entering it as input and clicking a Send button. When the user sends a message, the chat room returns another transcript of the entire conversation to display in the text area. The user disconnects by clicking the Disconnect button.

On the server side, there are five resources: a server, a client handler, a transcript, a thread-safe transcript, and a shared cell. Their roles are much the same as they are in the ATM application of Project 8. The server creates a thread-safe transcript at start-up, listens for client connections, and passes a client’s socket and the thread-safe transcript to a client handler when a client connects. The client handler receives the client’s name from the client socket, adds this name and the connection time to the thread-safe transcript, sends the thread-safe transcript’s string to the client, and waits for a reply. When the client’s reply comes in, the client handler adds the client’s name and time to it, adds the result to the thread-safe transcript, and sends the thread-safe transcript’s string back to the client. When the client disconnects, her name and a message to that effect are added to the thread-safe transcript.

The SharedCell class includes the usual read and write methods for a readers and writers protocol, and the SharedTranscript and Transcript classes include an add method and an __str__ method. The add method adds a string to a list of strings, while __str__ returns the join of this list, separated by newlines.